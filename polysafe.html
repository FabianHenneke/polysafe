<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>PolySafe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <label for="file">Choose a file to encrypt:</label>
    <input type="file" id="file"><br>
    <label for="password">Password:</label>
    <input type="password" id="password"><br>
    <label for="password_repeated">Repeat password:</label>
    <input type="password" id="password_repeated"><br>
    <input type="button" id="encrypt" value="Encrypt file">
    <script>
        "use strict";

        function getRandomBytes(num) {
            let bytes = new Uint8Array(num);
            window.crypto.getRandomValues(bytes);
            return bytes;
        }

        function readFile(file) {
            return new Uint8Array(new FileReader().readAsArrayBuffer(file));
        }

        function readFile(file) {
            const reader = new FileReader();

            return new Promise((resolve, reject) => {
                reader.onerror = () => {
                    reader.abort();
                    reject(new DOMException("Cannot read input file."));
                };

                reader.onload = () => {
                    resolve(new Uint8Array(reader.result));
                };
                reader.readAsArrayBuffer(file);
            });
        };

        function preprendFilename(filename, data_bytes) {
            const filename_bytes = new TextEncoder('utf-8').encode(filename + '/');
            const combined_bytes = new Uint8Array(filename_bytes.length + data_bytes.length);
            combined_bytes.set(filename_bytes, 0);
            combined_bytes.set(data_bytes, filename_bytes.length);
            return combined_bytes;
        }

        function deriveKey(password, salt) {
            const passwordBytes = new TextEncoder('utf-8').encode(password);
            return window.crypto.subtle.importKey(
                'raw',
                passwordBytes, {
                    name: 'PBKDF2',
                },
                false,
                ['deriveKey']
            ).then(function (key) {
                return window.crypto.subtle.deriveKey({
                        name: "PBKDF2",
                        salt,
                        iterations: 200000,
                        hash: {
                            name: "SHA-512"
                        }
                    },
                    key, {
                        name: "AES-GCM",
                        length: 256
                    },
                    false,
                    ['encrypt']
                )
            });
        }

        function encrypt(key, iv, bytes) {
            return window.crypto.subtle.encrypt({
                name: "AES-GCM",
                length: 256,
                iv
            }, key, bytes)
        }

        /*
        MIT LICENSE
        Copyright 2011 Jon Leighton
        Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
        The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
        */

        function base64ArrayBuffer(arrayBuffer) {
            let base64 = '';
            const encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

            const bytes = new Uint8Array(arrayBuffer);
            const byteLength = bytes.byteLength;
            const byteRemainder = byteLength % 3;
            const mainLength = byteLength - byteRemainder;

            let a, b, c, d;
            let chunk;

            // Main loop deals with bytes in chunks of 3
            for (var i = 0; i < mainLength; i = i + 3) {
                // Combine the three bytes into a single integer
                chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];

                // Use bitmasks to extract 6-bit segments from the triplet
                a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18
                b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12
                c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6
                d = chunk & 63; // 63       = 2^6 - 1

                // Convert the raw binary segments to the appropriate ASCII encoding;
                base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];
            }

            // Deal with the remaining bytes and padding
            if (byteRemainder == 1) {
                chunk = bytes[mainLength];

                a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2

                // Set the 4 least significant bits to zero
                b = (chunk & 3) << 4; // 3   = 2^2 - 1

                base64 += encodings[a] + encodings[b] + '==';
            } else if (byteRemainder == 2) {
                chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];

                a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10
                b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4

                // Set the 2 least significant bits to zero
                c = (chunk & 15) << 2; // 15    = 2^4 - 1

                base64 += encodings[a] + encodings[b] + encodings[c] + '=';
            }

            return base64;
        }

        function serialize(salt, iv, cipher_buffer) {
            const payload = JSON.stringify({
                salt: Array.prototype.slice.call(salt),
                iv: Array.prototype.slice.call(iv),
                encrypted: base64ArrayBuffer(cipher_buffer)
            });
            const decryptor_html = DECRYPTOR_TEMPLATE.replace('{{___PAYLOAD___}}', payload);
            return new TextEncoder('utf-8').encode(decryptor_html);
        }

        function download(filename, buffer) {
            const a = document.createElement('a');
            a.style = 'display: none';
            document.body.appendChild(a);
            const blob = new Blob([buffer], {
                type: 'application/octet-stream'
            });
            const url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function runEncrypt() {
            if (!window.crypto) {
                alert(
                    'Full support for the WebCrypto API is needed for decryption. Please use one of the following browsers: Chrome 37+, Firefox 34+, Safari 7+, Opera 24+'
                )
                return;
            }

            const file = document.getElementById('file').files[0];
            if (!file) {
                alert('Select a file.');
                return;
            }
            const password = document.getElementById('password').value;
            if (password != document.getElementById('password_repeated').value) {
                alert('Passwords must match.');
                return;
            }

            document.getElementById('encrypt').disabled = true;
            document.getElementById('encrypt').value = "Encrypting...";

            const salt = getRandomBytes(16);
            const iv = getRandomBytes(16);

            readFile(file)
                .then(file_bytes => preprendFilename(file.name, file_bytes))
                .then(payload_bytes => deriveKey(password, salt)
                    .then(key => encrypt(key, iv, payload_bytes)))
                .then(buffer => serialize(salt, iv, buffer))
                .then(buffer => download(file.name + '.html', buffer))
                .then(() => {
                    document.getElementById('encrypt').disabled = false;
                    document.getElementById('encrypt').value = "Encrypt file";
                });
        }

        document.getElementById('encrypt').addEventListener('click', runEncrypt);

        const DECRYPTOR_TEMPLATE =
            `
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>PolySafe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <label for="password">Password:</label>
    <input type="password" id="password">
    <input type="button" id="decrypt" value="Decrypt file">
    <script id="data" type="application/json">
        {{___PAYLOAD___}}
    <\/script>
    <script>
        function base64ToArray(base64) {
            return new Uint8Array(atob(base64).split('').map(function (c) {
                return c.charCodeAt(0);
            }));
        }

        function deriveKey(password, salt) {
            const passwordBytes = new TextEncoder('utf-8').encode(password);

            return window.crypto.subtle.importKey(
                'raw',
                passwordBytes, {
                    name: 'PBKDF2'
                },
                false,
                ['deriveKey']
            ).then(function (key) {
                return window.crypto.subtle.deriveKey({
                        name: 'PBKDF2',
                        salt,
                        iterations: 200000,
                        hash: {
                            name: 'SHA-512'
                        }
                    },
                    key, {
                        name: 'AES-GCM',
                        length: 256
                    },
                    false,
                    ['decrypt']
                )
            });
        }

        function decrypt(key, iv, bytes) {
            return window.crypto.subtle.decrypt({
                name: 'AES-GCM',
                length: 256,
                iv
            }, key, bytes)
        }

        function extractDecryptedFile(buffer) {
            const bytes = new Uint8Array(buffer);
            const slash_pos = bytes.indexOf('/'.charCodeAt(0));
            if (slash_pos == -1) {
                throw 'Decrypted data is corrupted';
            } else {
                const name = new TextDecoder('utf-8').decode(bytes.slice(0, slash_pos));
                const content = bytes.slice(slash_pos + 1);
                return {
                    name,
                    content
                };
            }
        }

        function download(filename, buffer) {
            const a = document.createElement('a');
            a.style = 'display: none';
            document.body.appendChild(a);
            blob = new Blob([buffer], {
                type: 'application/octet-stream'
            });
            url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function runDecrypt() {
            if (!window.crypto) {
                alert(
                    'Full support for the WebCrypto API is needed for decryption. Please use one of the following browsers: Chrome 37+, Firefox 34+, Safari 7+, Opera 24+'
                )
            }
            document.getElementById('decrypt').disabled = true;
            document.getElementById('decrypt').value = 'Decrypting...';

            const data = JSON.parse(document.getElementById('data').textContent);
            const salt = new Uint8Array(data.salt);
            const iv = new Uint8Array(data.iv);
            const encrypted = base64ToArray(data.encrypted);

            const password = document.getElementById('password').value;
            deriveKey(password, salt)
                .then(key => decrypt(key, iv, encrypted))
                .then(extractDecryptedFile)
                .then(file => download(file.name, file.content));

            document.getElementById('decrypt').disabled = false;
            document.getElementById('decrypt').value = 'Decrypt file';
        }

        document.getElementById('decrypt').addEventListener('click', runDecrypt);
    <\/script>
</body>

</html>
`;
    </script>
</body>

</html>
