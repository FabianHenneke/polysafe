<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>PolySafe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <label for="file">Choose a file to encrypt:</label>
    <input type="file" id="file"><br>
    <label for="password">Password:</label>
    <input type="password" id="password"><br>
    <label for="password_repeated">Repeat password:</label>
    <input type="password" id="password_repeated"><br>
    <input type="button" id="encrypt" value="Encrypt file">
    <script>
        function getRandomBytes(num) {
            let bytes = new Uint8Array(num);
            window.crypto.getRandomValues(bytes);
            return bytes;
        }

        function readFile(file) {
            return new Uint8Array(new FileReader().readAsArrayBuffer(file));
        }

        function readFile(file) {
            const reader = new FileReader();

            return new Promise((resolve, reject) => {
                reader.onerror = () => {
                    reader.abort();
                    reject(new DOMException("Cannot read input file."));
                };

                reader.onload = () => {
                    resolve(new Uint8Array(reader.result));
                };
                reader.readAsArrayBuffer(file);
            });
        };

        function preprendFilename(filename, data_bytes) {
            const filename_bytes = new TextEncoder('utf-8').encode(filename + '/');
            const combined_bytes = new Uint8Array(filename_bytes.length + data_bytes.length);
            combined_bytes.set(filename_bytes, 0);
            combined_bytes.set(data_bytes, filename_bytes.length);
            return combined_bytes;
        }

        function deriveKey(password, salt) {
            const passwordBytes = new TextEncoder('utf-8').encode(password);
            return window.crypto.subtle.importKey(
                'raw',
                passwordBytes, {
                    name: 'PBKDF2',
                },
                false,
                ['deriveKey']
            ).then(function (key) {
                return window.crypto.subtle.deriveKey({
                        name: "PBKDF2",
                        salt,
                        iterations: 200000,
                        hash: {
                            name: "SHA-512"
                        }
                    },
                    key, {
                        name: "AES-GCM",
                        length: 256
                    },
                    false,
                    ['encrypt']
                )
            });
        }

        function encrypt(key, iv, bytes) {
            return window.crypto.subtle.encrypt({
                name: "AES-GCM",
                length: 256,
                iv
            }, key, bytes)
        }

        function arrayToBase64(array) {
            let binary = '';
            let len = array.byteLength;
            for (let i = 0; i< len; i++) {
                binary += String.fromCharCode(array[i]);
            }
            return btoa(binary);
        }

        function serialize(salt, iv, cipher_buffer) {
            const payload = JSON.stringify({
                salt: Array.prototype.slice.call(salt),
                iv: Array.prototype.slice.call(iv),
                encrypted: arrayToBase64(new Uint8Array(cipher_buffer))
            });
            const decryptor_html = DECRYPTOR_TEMPLATE.replace('{{___PAYLOAD___}}', payload);
            return new TextEncoder('utf-8').encode(decryptor_html);
        }

        function download(filename, buffer) {
            const a = document.createElement('a');
            a.style = 'display: none';
            document.body.appendChild(a);
            blob = new Blob([buffer], {
                type: 'application/octet-stream'
            });
            url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function runEncrypt() {
            if (!window.crypto) {
                alert(
                    'Full support for the WebCrypto API is needed for decryption. Please use one of the following browsers: Chrome 37+, Firefox 34+, Safari 7+, Opera 24+'
                )
                return;
            }

            const file = document.getElementById('file').files[0];
            if (!file) {
                alert('Select a file.');
                return;
            }
            const password = document.getElementById('password').value;
            if (password != document.getElementById('password_repeated').value) {
                alert('Passwords must match.');
                return;
            }

            document.getElementById('encrypt').disabled = true;
            document.getElementById('encrypt').value = "Encrypting...";

            const salt = getRandomBytes(16);
            const iv = getRandomBytes(16);

            readFile(file)
                .then(file_bytes => preprendFilename(file.name, file_bytes))
                .then(payload_bytes => deriveKey(password, salt)
                    .then(key => encrypt(key, iv, payload_bytes)))
                .then(buffer => serialize(salt, iv, buffer))
                .then(buffer => download(file.name + '.html', buffer));

            document.getElementById('encrypt').disabled = false;
            document.getElementById('encrypt').value = "Encrypt file";
        }

        document.getElementById('encrypt').addEventListener('click', runEncrypt);

        const DECRYPTOR_TEMPLATE = `
<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <title>PolySafe</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
</head>

<body>
    <label for="password">Password:</label>
    <input type="password" id="password">
    <input type="button" id="decrypt" value="Decrypt file">
    <script id="data" type="application/json">
        {{___PAYLOAD___}}
    <\/script>
    <script>
        function base64ToArray(base64) {
            return new Uint8Array(atob(base64).split('').map(function (c) {
                return c.charCodeAt(0);
            }));
        }

        function deriveKey(password, salt) {
            const passwordBytes = new TextEncoder('utf-8').encode(password);

            return window.crypto.subtle.importKey(
                'raw',
                passwordBytes, {
                    name: 'PBKDF2'
                },
                false,
                ['deriveKey']
            ).then(function (key) {
                return window.crypto.subtle.deriveKey({
                        name: 'PBKDF2',
                        salt,
                        iterations: 200000,
                        hash: {
                            name: 'SHA-512'
                        }
                    },
                    key, {
                        name: 'AES-GCM',
                        length: 256
                    },
                    false,
                    ['decrypt']
                )
            });
        }

        function decrypt(key, iv, bytes) {
            return window.crypto.subtle.decrypt({
                name: 'AES-GCM',
                length: 256,
                iv
            }, key, bytes)
        }

        function extractDecryptedFile(buffer) {
            const bytes = new Uint8Array(buffer);
            const slash_pos = bytes.indexOf('/'.charCodeAt(0));
            if (slash_pos == -1) {
                throw 'Decrypted data is corrupted';
            } else {
                const name = new TextDecoder('utf-8').decode(bytes.slice(0, slash_pos));
                const content = bytes.slice(slash_pos + 1);
                return {
                    name,
                    content
                };
            }
        }

        function download(filename, buffer) {
            const a = document.createElement('a');
            a.style = 'display: none';
            document.body.appendChild(a);
            blob = new Blob([buffer], {
                type: 'application/octet-stream'
            });
            url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function runDecrypt() {
            if (!window.crypto) {
                alert(
                    'Full support for the WebCrypto API is needed for decryption. Please use one of the following browsers: Chrome 37+, Firefox 34+, Safari 7+, Opera 24+'
                )
            }
            document.getElementById('decrypt').disabled = true;
            document.getElementById('decrypt').value = 'Decrypting...';

            const data = JSON.parse(document.getElementById('data').textContent);
            const salt = new Uint8Array(data.salt);
            const iv = new Uint8Array(data.iv);
            const encrypted = base64ToArray(data.encrypted);

            const password = document.getElementById('password').value;
            deriveKey(password, salt)
                .then(key => decrypt(key, iv, encrypted))
                .then(extractDecryptedFile)
                .then(file => download(file.name, file.content));

            document.getElementById('decrypt').disabled = false;
            document.getElementById('decrypt').value = 'Decrypt file';
        }

        document.getElementById('decrypt').addEventListener('click', runDecrypt);
    <\/script>
</body>

</html>
`;
    </script>
</body>

</html>
